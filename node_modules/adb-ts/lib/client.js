"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Client = void 0;
const util_1 = require("./util");
const sync_1 = require("./sync");
const child_process_1 = require("child_process");
const fs_1 = __importDefault(require("fs"));
const device_1 = require("./device");
const batteryStatus_1 = __importDefault(require("./commands/host-transport/batteryStatus"));
const clear_1 = __importDefault(require("./commands/host-transport/clear"));
const connect_1 = __importDefault(require("./commands/host/connect"));
const connection_1 = require("./connection");
const cp_1 = __importDefault(require("./commands/host-transport/fileSystem/cp"));
const disconnect_1 = __importDefault(require("./commands/host/disconnect"));
const fileStat_1 = __importDefault(require("./commands/host-transport/fileStat"));
const forward_1 = __importDefault(require("./commands/host-serial/forward"));
const getdevicepath_1 = __importDefault(require("./commands/host-serial/getdevicepath"));
const ipaddress_1 = __importDefault(require("./commands/host-transport/ipaddress"));
const getproperty_1 = __importDefault(require("./commands/host-transport/getproperty"));
const getsetting_1 = __importDefault(require("./commands/host-transport/getsetting"));
const transport_1 = __importDefault(require("./commands/host/transport"));
const install_1 = __importDefault(require("./commands/host-transport/install"));
const isinstalled_1 = __importDefault(require("./commands/host-transport/isinstalled"));
const kill_1 = __importDefault(require("./commands/host/kill"));
const listdevices_1 = __importDefault(require("./commands/host/listdevices"));
const listfeatures_1 = __importDefault(require("./commands/host-transport/listfeatures"));
const listforwards_1 = __importDefault(require("./commands/host-serial/listforwards"));
const listpackages_1 = __importDefault(require("./commands/host-transport/listpackages"));
const listproperties_1 = __importDefault(require("./commands/host-transport/listproperties"));
const listreverses_1 = __importDefault(require("./commands/host-transport/listreverses"));
const listSettings_1 = __importDefault(require("./commands/host-transport/listSettings"));
const logcat_1 = __importDefault(require("./commands/host-transport/logcat"));
const mkdir_1 = __importDefault(require("./commands/host-transport/fileSystem/mkdir"));
const client_1 = require("./monkey/client");
const monkey_2 = __importDefault(require("./commands/host-transport/monkey"));
const mv_1 = __importDefault(require("./commands/host-transport/fileSystem/mv"));
const putSetting_1 = __importDefault(require("./commands/host-transport/putSetting"));
const stream_1 = require("stream");
const reboot_1 = __importDefault(require("./commands/host-transport/reboot"));
const remount_1 = __importDefault(require("./commands/host-transport/remount"));
const reverse_1 = __importDefault(require("./commands/host-transport/reverse"));
const rm_1 = __importDefault(require("./commands/host-transport/fileSystem/rm"));
const root_1 = __importDefault(require("./commands/host-transport/root"));
const screencap_1 = __importDefault(require("./commands/host-transport/screencap"));
const setProperty_1 = __importDefault(require("./commands/host-transport/setProperty"));
const shell_1 = __importDefault(require("./commands/host-transport/shell"));
const deleteApk_1 = __importDefault(require("./commands/host-transport/deleteApk"));
const shutdown_1 = __importDefault(require("./commands/host-transport/shutdown"));
const startActivity_1 = __importDefault(require("./commands/host-transport/startActivity"));
const startservice_1 = __importDefault(require("./commands/host-transport/startservice"));
const sync_2 = __importDefault(require("./commands/host-transport/sync"));
const tcp_1 = __importDefault(require("./commands/host-transport/tcp"));
const tcpip_1 = __importDefault(require("./commands/host-transport/tcpip"));
const touch_1 = __importDefault(require("./commands/host-transport/fileSystem/touch"));
const trackdevices_1 = __importDefault(require("./commands/host/trackdevices"));
const tracker_1 = require("./tracker");
const uninstall_1 = __importDefault(require("./commands/host-transport/uninstall"));
const usb_1 = __importDefault(require("./commands/host-transport/usb"));
const version_1 = __importDefault(require("./commands/host/version"));
const waitBootComplete_1 = __importDefault(require("./commands/host-transport/waitBootComplete"));
const waitFor_1 = __importDefault(require("./commands/host/waitFor"));
const util_2 = require("util");
const promises_1 = __importDefault(require("timers/promises"));
const text_1 = __importDefault(require("./commands/host-transport/input/text"));
const roll_1 = __importDefault(require("./commands/host-transport/input/roll"));
const dragAndDrop_1 = __importDefault(require("./commands/host-transport/input/dragAndDrop"));
const swipe_1 = __importDefault(require("./commands/host-transport/input/swipe"));
const press_1 = __importDefault(require("./commands/host-transport/input/press"));
const keyEvent_1 = __importDefault(require("./commands/host-transport/input/keyEvent"));
const tap_1 = __importDefault(require("./commands/host-transport/input/tap"));
const ADB_DEFAULT_PORT = 5555;
const DEFAULT_OPTIONS = {
    port: 5037,
    host: '127.0.0.1',
    bin: 'adb',
    noAutoStart: false
};
class Client {
    /**
     * @param {AdbClientOptions} options see AdbClientOptions for more details
     */
    constructor(options) {
        this.options = Object.entries(options || {})
            .filter(([, value]) => typeof value !== 'undefined')
            .reduce((def, [key, value]) => ({ ...def, [key]: value }), DEFAULT_OPTIONS);
    }
    /**
     * Starts adb server if not running.
     */
    startServer() {
        const port = this.options.port;
        const args = ['-P', port.toString(), 'start-server'];
        return (0, util_2.promisify)((cb_) => (0, child_process_1.execFile)(this.options.bin, args, (err) => cb_(err)))();
    }
    connection() {
        return new Promise((resolve, reject) => {
            let triedStarting = false;
            const connection = new connection_1.Connection();
            const errorListener = async (err) => {
                if (err.code === 'ECONNREFUSED' &&
                    !triedStarting &&
                    !this.options.noAutoStart) {
                    triedStarting = true;
                    await this.startServer();
                    connection.connect(this.options);
                    return;
                }
                connection.destroy();
                return reject(err);
            };
            connection.on('error', errorListener);
            connection.once('connect', () => {
                connection.off('error', errorListener);
                return resolve(connection);
            });
            connection.connect(this.options);
        });
    }
    async transport(serial) {
        const conn = await this.connection();
        await new transport_1.default(conn, serial).execute();
        return conn;
    }
    /**
     * Gets the adb server version.
     */
    async version() {
        return new version_1.default(await this.connection()).execute();
    }
    async ipConnect(Construct, host, port) {
        if (host.indexOf(':') !== -1) {
            const [h, p] = host.split(':', 2);
            host = h;
            port = parseInt(p);
        }
        const conn = await this.connection();
        return new Construct(conn, host, (0, util_1.parsePrimitiveParam)(ADB_DEFAULT_PORT, port)).execute();
    }
    connect(host, port) {
        return this.ipConnect(connect_1.default, host, port);
    }
    disconnect(host, port) {
        return this.ipConnect(disconnect_1.default, host, port);
    }
    /**
     * Gets the list of currently connected devices and emulators.
     */
    async listDevices() {
        return new listdevices_1.default(await this.connection()).execute();
    }
    /**
     * Tracks connection status of devices.
     */
    async trackDevices() {
        const conn = await this.connection();
        const command = new trackdevices_1.default(conn);
        await command.execute();
        return new tracker_1.Tracker(command, this);
    }
    /**
     * Kills the adb server.
     */
    async kill() {
        let connection;
        try {
            connection = await this.connection();
        }
        catch (error) {
            if (error?.code === 'ECONNREFUSED') {
                return;
            }
            throw error;
        }
        return new kill_1.default(connection).execute();
    }
    /**
     * Gets the serial number of the device.
     * Meant for getting serial number of local devices.
     * Analogous to `adb shell getprop ro.serialno`.
     */
    async getSerialNo(serial) {
        const serialNo = await this.getProp(serial, 'ro.serialno');
        return String(serialNo);
    }
    /**
     * Gets the device path of the device identified by the device.
     */
    async getDevicePath(serial) {
        return new getdevicepath_1.default(await this.connection(), serial).execute();
    }
    /**
     * Lists properties of the device.
     * Analogous to `adb shell getprop`.
     */
    async listProperties(serial) {
        return new listproperties_1.default(await this.connection(), serial).execute();
    }
    /**
     * Lists features of the device.
     * Analogous to `adb shell pm list features`.
     */
    async listFeatures(serial) {
        return new listfeatures_1.default(await this.connection(), serial).execute();
    }
    /**
     * Lists installed packages.
     * Analogous to `adb shell pm list packages`.
     */
    async listPackages(serial) {
        return new listpackages_1.default(await this.connection(), serial).execute();
    }
    /**
     * Gets the ipv4 addresses of default wlan interface.
     */
    async getIpAddress(serial) {
        return new ipaddress_1.default(await this.connection(), serial).execute();
    }
    /**
     * Forwards socket connections from the ADB server host (local) to the device (remote).
     * Analogous to `adb forward <local> <remote>`.
     * @example
     * adb.forward('serial', 'tcp:9222', 'localabstract:chrome_devtools_remote')
     */
    async forward(serial, local, remote) {
        return new forward_1.default(await this.connection(), serial, local, remote).execute();
    }
    /**
     * Lists all forwarded connections.
     * Analogous to `adb forward --list`.
     */
    async listForwards(serial) {
        return new listforwards_1.default(await this.connection(), serial).execute();
    }
    /**
     * Reverses socket connections from the device (remote) to the ADB server host (local).
     * Analogous to `adb reverse <remote> <local>`.
     * @example
     * adb.reverse('serial', 'localabstract:chrome_devtools_remote', 'tcp:9222')
     */
    async reverse(serial, local, remote) {
        return new reverse_1.default(await this.connection(), serial, local, remote).execute();
    }
    /**
     * Lists all reversed connections.
     * Analogous to `adb reverse --list`.
     */
    async listReverses(serial) {
        return new listreverses_1.default(await this.connection(), serial).execute();
    }
    async deleteApk(serial, pathToApk) {
        return new deleteApk_1.default(await this.connection(), serial, pathToApk).execute();
    }
    /**
     * Reboots the device.
     * Analogous to `adb reboot`.
     */
    async reboot(serial) {
        return new reboot_1.default(await this.connection(), serial).execute();
    }
    /**
     * Shuts the device down.
     * Analogous to `adb reboot -p`.
     */
    async shutdown(serial) {
        return new shutdown_1.default(await this.connection(), serial).execute();
    }
    /**
     * Attempts to remount the `/system` partition in read-write mode.
     * Can be done on a rooted device. Analogous to `adb remount`.
     * Analogous to `adb remount`
     */
    async remount(serial) {
        return new remount_1.default(await this.connection(), serial).execute();
    }
    /**
     * Attempts to which the device to the root mode.
     * Analogous to `adb root`.
     */
    async root(serial) {
        return new root_1.default(await this.connection(), serial).execute();
    }
    /**
     * Takes a screenshot on the specified device.
     * Analogous to `adb shell screencap -p`.
     */
    async screenshot(serial) {
        return new screencap_1.default(await this.connection(), serial).execute();
    }
    async openTcp(serial, port, host) {
        return new tcp_1.default(await this.connection(), serial, port, host).execute();
    }
    async roll(serial, x, y, source) {
        return new roll_1.default(await this.connection(), serial, {
            source,
            x,
            y
        }).execute();
    }
    async press(serial, source) {
        return new press_1.default(await this.connection(), serial, source).execute();
    }
    async dragAndDrop(serial, x1, y1, x2, y2, options) {
        return new dragAndDrop_1.default(await this.connection(), serial, {
            x1,
            y1,
            x2,
            y2,
            options
        }).execute();
    }
    async swipe(serial, x1, y1, x2, y2, options) {
        return new swipe_1.default(await this.connection(), serial, {
            x1,
            y1,
            x2,
            y2,
            options
        }).execute();
    }
    async keyEvent(serial, code, options) {
        return new keyEvent_1.default(await this.connection(), serial, {
            options,
            code
        }).execute();
    }
    async tap(serial, x, y, source) {
        return new tap_1.default(await this.connection(), serial, {
            source,
            x,
            y
        }).execute();
    }
    async text(serial, text, source) {
        return new text_1.default(await this.connection(), serial, {
            source,
            text
        }).execute();
    }
    async openLogcat(serial, options) {
        return new logcat_1.default(await this.connection(), serial, options).execute();
    }
    syncService(serial) {
        return this.connection().then((conn) => {
            return new sync_2.default(conn, serial).execute();
        });
    }
    /**
     * Deletes all data associated with a package from the device.
     * Analogous to `adb shell pm clear <pkg>`.
     */
    async clear(serial, pkg) {
        return new clear_1.default(await this.connection(), serial, pkg).execute();
    }
    async installRemote(serial, apk, options, args) {
        await new install_1.default(await this.connection(), serial, apk, options, args).execute();
        return this.deleteApk(serial, apk);
    }
    async install(serial, apk, options, args) {
        const temp = sync_1.Sync.temp(typeof apk === 'string' ? apk : '_stream.apk');
        return (0, util_1.autoUnregister)(await this.push(serial, apk, temp), (transfer) => new Promise((resolve, reject) => {
            transfer.on('error', reject).on('end', () => {
                this.installRemote(serial, temp, options, args)
                    .then(resolve)
                    .catch(reject);
            });
        }));
    }
    async uninstall(serial, pkg, options) {
        return new uninstall_1.default(await this.connection(), serial, pkg, options).execute();
    }
    /**
     * Tells if a package is installed or not.
     */
    async isInstalled(serial, pkg) {
        return new isinstalled_1.default(await this.connection(), serial, pkg).execute();
    }
    async startActivity(serial, pkg, activity, options) {
        return new startActivity_1.default(await this.connection(), serial, pkg, activity, options).execute();
    }
    async startService(serial, pkg, service, options) {
        return new startservice_1.default(await this.connection(), serial, pkg, service, options).execute();
    }
    /**
     * Reads given directory.
     * The path should start with `/`.
     */
    async readDir(serial, path) {
        const sync = await this.syncService(serial);
        try {
            return await sync.readDir(path);
        }
        finally {
            sync.end();
        }
    }
    /**
     * Gets a PullTransfer instance.
     * @see `PullTransfer`
     * @example
     * let data = '';
     * const transfer = await adb.pull('serial', '/path')
     * transfer.on('data', (chunk) => {
     *     data += chunk.toString();
     * });
     * transfer.on('end', () => {
     *     console.log(data);
     * });
     */
    async pull(serial, path) {
        const sync = await this.syncService(serial);
        return sync.pull(path).on('end', () => sync.end());
    }
    async push(serial, srcPath, destPath, mode) {
        const sync = await this.syncService(serial);
        return sync.push(srcPath, destPath, mode).on('end', () => sync.end());
    }
    async awaitActiveDevice(serial) {
        const track = (tracker) => {
            return new Promise((resolve, reject) => {
                const activeDeviceListener = (device) => {
                    if (device.id === serial &&
                        (device.state === 'device' ||
                            device.state === 'emulator')) {
                        resolve();
                    }
                };
                tracker.once('error', reject);
                tracker.once('remove', (device) => {
                    if (device.id === serial) {
                        tracker.once('add', activeDeviceListener);
                        tracker.once('change', activeDeviceListener);
                    }
                });
            });
        };
        const tracker = await this.trackDevices();
        try {
            return await Promise.race([
                promises_1.default.setTimeout(5000, undefined, { ref: false }),
                track(tracker)
            ]);
        }
        finally {
            tracker.end();
        }
    }
    async tcpip(serial, port) {
        return new tcpip_1.default(await this.connection(), serial, this.awaitActiveDevice(serial), (0, util_1.parsePrimitiveParam)(ADB_DEFAULT_PORT, port)).execute();
    }
    /**
     * Sets the device transport back to usb.
     */
    async usb(serial) {
        return new usb_1.default(await this.connection(), serial, this.awaitActiveDevice(serial)).execute();
    }
    /**
     * Waits until the device has finished booting.
     */
    async waitBootComplete(serial) {
        return new waitBootComplete_1.default(await this.connection(), serial).execute();
    }
    /**
     * Waits until the device is in the given state.
     * Analogous to `adb wait-for-<transport>-<state>`.
     */
    async waitFor(transport, state) {
        return new waitFor_1.default(await this.connection(), transport, state).execute();
    }
    /**
     * Maps through all connected devices.
     */
    async map(mapper) {
        const devices = await this.listDevices();
        return Promise.all(devices.map((device) => mapper(new device_1.Device(this, device))));
    }
    async pushInternal(serial, data, dest) {
        const transfer = await this.push(serial, data, dest);
        return new Promise((resolve, reject) => {
            transfer.once('end', resolve);
            transfer.once('error', reject);
        });
    }
    /**
     * Wraps {@link push} method, provides API for quick data writing.
     */
    pushDataToFile(serial, data, destPath) {
        return this.pushInternal(serial, stream_1.Readable.from(typeof data === 'string' ? Buffer.from(data, 'utf-8') : data), destPath);
    }
    /**
     * Wraps {@link push} method, reads the content of file on the host to a file on the device.
     */
    pushFile(serial, srcPath, destPath) {
        return this.pushInternal(serial, srcPath, destPath);
    }
    /**
     * Wraps {@link pull} method, reads the file content and resolves with the output.
     */
    async pullDataFromFile(serial, srcPath) {
        const transfer = await this.pull(serial, srcPath);
        return new Promise((resolve, reject) => {
            const chunks = [];
            transfer.on('data', (chunk) => {
                Buffer.isBuffer(chunk) && chunks.push(chunk);
            });
            transfer.on('end', () => resolve(Buffer.concat(chunks)));
            transfer.on('error', reject);
        });
    }
    /**
     * Wraps {@link pull} method, reads the content of file on the device and write it to a file on the machine.
     */
    async pullFile(serial, srcPath, destPath) {
        return (0, util_1.autoUnregister)(this.pull(serial, srcPath), (transfer) => new Promise((resolve, reject) => {
            transfer
                .once('readable', () => transfer.pipe(fs_1.default.createWriteStream(destPath)))
                .once('end', resolve)
                .once('error', reject);
        }));
    }
    /**
     * Sets property on the device.
     * Analogues to `adb shell setprop <prop> <value>`.
     */
    async setProp(serial, prop, value) {
        return new setProperty_1.default(await this.connection(), serial, prop, value).execute();
    }
    /**
     * Gets property from the device.
     * Analogues to `adb shell getprop <prop>`.
     */
    async getProp(serial, prop) {
        return new getproperty_1.default(await this.connection(), serial, prop).execute();
    }
    /**
     * Puts setting on the device.
     * Analogues to `adb shell settings put <mode> <name> <value>`.
     */
    async putSetting(serial, mode, name, value) {
        return new putSetting_1.default(await this.connection(), serial, mode, name, value).execute();
    }
    /**
     * Lists settings of the device.
     * Analogues to `adb shell settings list <mode>`.
     */
    async listSettings(serial, mode) {
        return new listSettings_1.default(await this.connection(), serial, mode).execute();
    }
    /**
     * Gets setting from the device.
     * Analogues to `adb shell settings get <mode> <name>`.
     */
    async getSetting(serial, mode, name) {
        return new getsetting_1.default(await this.connection(), serial, mode, name).execute();
    }
    /**
     * Executes a given shell command via adb console interface. Analogous to `adb -s <serial> shell <command>`.
     */
    async shell(serial, command) {
        return new shell_1.default(await this.connection(), serial, command).execute();
    }
    /**
     * Enables to execute any custom command.
     * @example
     *   class MyCommand extends Command<number> {
     *   protected autoEnd = true;
     *   private arg: string;
     *   constructor(connection: Connection, arg: string) {
     *       super(connection);
     *       this.arg = arg;
     *   }
     *   async execute(): Promise<number> {
     *       const reply = await this.initExecute(this.arg);
     *       switch (reply) {
     *           case Reply.OKAY:
     *               const value = await this.parser.readValue();
     *               return parseInt(value.toString(), 10);
     *           case Reply.FAIL:
     *               throw await this.parser.readError();
     *           default:
     *               return parseInt(reply, 10);
     *          }
     *      }
     *  }
     */
    async custom(CustomCommand, ...args) {
        const conn = await this.connection();
        return new CustomCommand(conn, ...args).execute();
    }
    /**
     * Enables to execute any custom transport command.
     * @example
     *    class MyCommand extends TransportCommand<null> {
     *    protected keepAlive = false;
     *    private arg: string;
     *    constructor(connection: Connection, serial: string, arg: string) {
     *        super(connection, serial);
     *        this.arg = arg;
     *    }
     *    protected get Cmd() {
     *        return 'test '.concat(this.arg);
     *    }
     *    protected postExecute(): null {
     *        return null;
     *    }
     * }
     */
    async customTransport(CustomCommand, serial, ...args) {
        const conn = await this.connection();
        return new CustomCommand(conn, serial, ...args).execute();
    }
    /**
     * Establishes a new monkey connection on port `1080`.
     */
    openMonkey(serial) {
        const tryConnect = async (times) => {
            try {
                const stream = await this.openTcp(serial, 1080);
                return new client_1.Monkey().connect(stream);
            }
            catch (err) {
                if ((times -= 1)) {
                    await promises_1.default.setTimeout(100);
                    return tryConnect(times);
                }
                throw err;
            }
        };
        const establishConnection = async (attempts) => {
            const tryConnectHandler = async (conn, monkey) => {
                await promises_1.default.setTimeout(100);
                const hookMonkey = async () => {
                    return monkey.once('end', () => conn.end());
                };
                if (monkey.stream.readyState !== 'closed') {
                    return hookMonkey();
                }
                conn.end();
                // if attempts fail, return monkey anyway
                return attempts === 0
                    ? hookMonkey()
                    : establishConnection(attempts - 1);
            };
            const transport = await this.transport(serial);
            const conn_2 = await new monkey_2.default(transport, serial, 1080).execute();
            return tryConnect(20).then((monkey_1) => tryConnectHandler(conn_2, monkey_1), (err) => {
                conn_2.end();
                throw err;
            });
        };
        return establishConnection(3);
    }
    /**
     * Force stops given package.
     * Analogous to `adb shell am force-stop <package>`.
     */
    async killApp(serial, pkg) {
        await this.shell(serial, `am force-stop ${pkg}`);
    }
    execInternal(args) {
        return new Promise((resolve, reject) => {
            (0, child_process_1.execFile)(this.options.bin, args, (err, stdout, stderr) => {
                if (err) {
                    return reject(err);
                }
                if (stderr && !stdout) {
                    return reject(new util_1.AdbExecError(stderr.trim(), args.join(' ')));
                }
                if (/Error/.test(stdout)) {
                    return reject(new util_1.AdbExecError(stdout.trim(), args.join(' ')));
                }
                return resolve(stdout);
            });
        });
    }
    /**
     * Executes a given command via adb console interface.
     * If cmd contains arguments, they need to be passed as and string[], not string. @see https://github.com/Maaaartin/adb-ts/issues/13
     */
    exec(cmd) {
        return this.execInternal([cmd].flat());
    }
    /**
     * Executes a given command on specific device via adb console interface.
     * Analogous to `adb -s <serial> <command>`.
     * If cmd contains arguments, they need to be passed as and string[], not string. @see https://github.com/Maaaartin/adb-ts/issues/13
     */
    execDevice(serial, cmd) {
        return this.execInternal(['-s', serial].concat(cmd));
    }
    /**
     * Executes a given command on specific device shell via adb console interface.
     * Analogous to `adb -s <serial> shell <command>` .
     */
    execDeviceShell(serial, cmd) {
        return this.execInternal(['-s', serial, 'shell'].concat(cmd));
    }
    /**
     * Retrieves current battery status.
     * Analogous to `adb -s <serial> shell dumpsys battery` .
     */
    async batteryStatus(serial) {
        return new batteryStatus_1.default(await this.connection(), serial).execute();
    }
    async rm(serial, path, options) {
        return new rm_1.default(await this.connection(), serial, path, options).execute();
    }
    async mkdir(serial, path, options) {
        return new mkdir_1.default(await this.connection(), serial, path, options).execute();
    }
    async touch(serial, path, options) {
        return new touch_1.default(await this.connection(), serial, path, options).execute();
    }
    async mv(serial, srcPath, destPath, options) {
        return new mv_1.default(await this.connection(), serial, [srcPath, destPath], options).execute();
    }
    async cp(serial, srcPath, destPath, options) {
        return new cp_1.default(await this.connection(), serial, [srcPath, destPath], options).execute();
    }
    /**
     * Gets file stats for specified path.
     * Analogous to `adb stat <filepath>`.
     */
    async fileStat(serial, path) {
        return new fileStat_1.default(await this.connection(), serial, path).execute();
    }
}
exports.Client = Client;
