"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Parser = void 0;
const functions_1 = require("./util//functions");
const util_1 = require("./util");
const promises_1 = __importDefault(require("timers/promises"));
class Parser {
    constructor(socket) {
        this.ended = false;
        this.socket = socket;
    }
    readBytes(howMany) {
        return (0, util_1.autoUnregister)(this.socket, (socket) => new Promise((resolve, reject) => {
            const tryRead = () => {
                if (!howMany) {
                    return resolve(Buffer.alloc(0));
                }
                const chunk = this.socket.read(howMany);
                if (chunk) {
                    howMany -= chunk.length;
                    if (howMany === 0) {
                        return resolve(chunk);
                    }
                }
                if (this.ended) {
                    return reject(new util_1.PrematureEOFError(howMany));
                }
            };
            socket
                .on('readable', tryRead)
                .on('error', reject)
                .on('end', () => {
                this.ended = true;
                reject(new util_1.PrematureEOFError(howMany));
            });
            tryRead();
        }));
    }
    end() {
        return (0, util_1.autoUnregister)(this.socket, (socket) => new Promise((resolve, reject) => {
            socket
                .on('readable', () => {
                while (this.socket.read()) {
                    continue;
                }
            })
                .on('error', reject)
                .on('end', () => {
                this.ended = true;
                resolve();
            });
            if (this.ended) {
                return resolve();
            }
            this.socket.read(0);
            this.socket.end();
        }));
    }
    async readAscii(howMany) {
        return (await this.readBytes(howMany)).toString('ascii');
    }
    async readValue() {
        const value = await this.readAscii(4);
        const length = (0, functions_1.decodeLength)(value);
        return this.readBytes(length);
    }
    readError() {
        return Promise.race([
            promises_1.default.setTimeout(1000, new Error('Could not read error'), {
                ref: false
            }),
            this.readValue().then(String).then(Error)
        ]);
    }
    unexpected(data, expected) {
        return new util_1.UnexpectedDataError(data, expected);
    }
    readByteFlow(howMany, targetStream) {
        return (0, util_1.autoUnregister)(this.socket, (socket) => new Promise((resolve, reject) => {
            const tryRead = () => {
                if (!howMany) {
                    return resolve();
                }
                const readAll = (chunk = this.socket.read(howMany) ||
                    this.socket.read()) => {
                    if (!chunk) {
                        return false;
                    }
                    howMany -= chunk.length;
                    targetStream.write(chunk);
                    return howMany === 0 || readAll();
                };
                if (readAll()) {
                    return resolve();
                }
                if (this.ended) {
                    return reject(new util_1.PrematureEOFError(howMany));
                }
            };
            socket
                .on('readable', tryRead)
                .on('error', reject)
                .on('end', () => {
                this.ended = true;
                reject(new util_1.PrematureEOFError(howMany));
            });
            tryRead();
        }));
    }
    readUntil(code) {
        const read = async (skipped = Buffer.alloc(0)) => {
            const chunk = await this.readBytes(1);
            if (chunk[0] === code) {
                return skipped;
            }
            return read(Buffer.concat([skipped, chunk]));
        };
        return read();
    }
    async readline() {
        const line = await this.readUntil(10);
        if (line[line.length - 1] === 13) {
            return line.subarray(0, -1);
        }
        return line;
    }
    async searchLine(regExp, retry = true) {
        const line = (await this.readline()).toString();
        const match = regExp.exec(line);
        if (match) {
            return match;
        }
        if (retry) {
            return this.searchLine(regExp);
        }
        throw new util_1.UnexpectedDataError(line, regExp.toString());
    }
    readAll() {
        return (0, util_1.autoUnregister)(this.socket, (socket) => new Promise((resolve, reject) => {
            const chunks = [];
            const tryRead = () => {
                while (this.socket.readableLength) {
                    chunks.push(this.socket.read());
                }
                if (this.ended) {
                    return resolve(Buffer.concat(chunks));
                }
            };
            socket
                .on('readable', tryRead)
                .on('error', reject)
                .on('end', () => {
                this.ended = true;
                return resolve(Buffer.concat(chunks));
            });
        }));
    }
}
exports.Parser = Parser;
