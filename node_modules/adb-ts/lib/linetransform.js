"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const stream_1 = require("stream");
class LineTransform extends stream_1.Transform {
    constructor(options) {
        super(options);
        this.savedR = null;
        this.transformNeeded = true;
        this.skipBytes = 0;
        this.autoDetect = options?.autoDetect || false;
    }
    nullTransform(chunk, _encoding, cb) {
        this.push(chunk);
        cb();
    }
    _transform(chunk, encoding, cb) {
        if (this.autoDetect) {
            if (chunk[0] === 0x0a) {
                this.transformNeeded = false;
                this.skipBytes = 1;
            }
            else {
                this.skipBytes = 2;
            }
            this.autoDetect = false;
        }
        if (this.skipBytes) {
            const skip = Math.min(chunk.length, this.skipBytes);
            chunk = chunk.subarray(skip);
            this.skipBytes -= skip;
        }
        if (!chunk.length) {
            return cb();
        }
        if (!this.transformNeeded) {
            return this.nullTransform(chunk, encoding, cb);
        }
        let lo = 0;
        let hi = 0;
        if (this.savedR) {
            if (chunk[0] !== 0x0a) {
                this.push(this.savedR);
            }
            this.savedR = null;
        }
        const last = chunk.length - 1;
        while (hi <= last) {
            if (chunk[hi] === 0x0d) {
                if (hi === last) {
                    this.savedR = chunk.subarray(last);
                    break;
                }
                else if (chunk[hi + 1] === 0x0a) {
                    this.push(chunk.subarray(lo, hi));
                    lo = hi + 1;
                }
            }
            hi += 1;
        }
        if (hi !== lo) {
            this.push(chunk.subarray(lo, hi));
        }
        cb();
    }
    _flush(cb) {
        if (this.savedR) {
            this.push(this.savedR);
        }
        return cb();
    }
}
exports.default = LineTransform;
