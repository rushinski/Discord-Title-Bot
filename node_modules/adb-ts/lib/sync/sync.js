"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Sync = exports.SyncMode = void 0;
const util_1 = require("../util");
const events_1 = require("events");
const path_1 = __importDefault(require("path"));
const pulltransfer_1 = require("./pulltransfer");
const pushtransfer_1 = require("./pushtransfer");
const stats_1 = __importDefault(require("./stats"));
const entry_1 = __importDefault(require("./entry"));
const fs_1 = __importDefault(require("fs"));
const util_2 = require("util");
var SyncMode;
(function (SyncMode) {
    SyncMode[SyncMode["DEFAULT_CHMOD"] = 420] = "DEFAULT_CHMOD";
    SyncMode[SyncMode["DATA_MAX_LENGTH"] = 65536] = "DATA_MAX_LENGTH";
})(SyncMode || (exports.SyncMode = SyncMode = {}));
class Sync extends events_1.EventEmitter {
    constructor(connection) {
        super();
        this.connection = connection;
        this.parser = connection.parser;
    }
    static temp(path) {
        return `/data/local/tmp/${path_1.default.basename(path)}`;
    }
    async error() {
        const length = await this.parser.readBytes(4);
        const buff = await this.parser.readBytes(length.readUInt32LE(0));
        throw new Error(buff.toString());
    }
    sendCommandWithLength(cmd, length) {
        const payload = Buffer.alloc(cmd.length + 4);
        payload.write(cmd, 0, cmd.length);
        payload.writeUInt32LE(length, cmd.length);
        return this.connection.write(payload);
    }
    getDrainAwaiter() {
        let cb_ = null;
        const listener_ = () => {
            cb_?.(null);
            cb_ = null;
        };
        this.connection.on('drain', listener_);
        const waitForDrain = (cb) => {
            cb_ = cb;
        };
        const unregisterDrainListener = () => {
            this.connection.off('drain', listener_);
        };
        return { waitForDrain, unregisterDrainListener };
    }
    writeData(stream, timestamp) {
        const transfer = new pushtransfer_1.PushTransfer();
        const didWrite = (chunk) => (0, util_2.promisify)((cb) => {
            const result = this.connection.write(chunk, (err) => {
                if (err) {
                    return cb(err, false);
                }
                transfer.pop();
                cb(null, result);
            });
        })();
        let canceled = false;
        const writeData = async () => {
            const { waitForDrain, unregisterDrainListener } = this.getDrainAwaiter();
            const promise = new Promise((resolve, reject) => {
                const writeNext = async () => {
                    const chunk = stream.read(SyncMode.DATA_MAX_LENGTH) || stream.read();
                    if (Buffer.isBuffer(chunk)) {
                        this.sendCommandWithLength(util_1.Reply.DATA, chunk.length);
                        transfer.push(chunk.length);
                        if (await didWrite(chunk)) {
                            return writeNext();
                        }
                        await (0, util_2.promisify)(waitForDrain)();
                        return writeNext();
                    }
                };
                stream
                    .on('end', () => {
                    this.sendCommandWithLength(util_1.Reply.DONE, timestamp);
                    resolve();
                })
                    .on('readable', writeNext)
                    .on('error', reject);
                this.connection.on('error', (err) => {
                    stream.destroy();
                    this.connection.end();
                    reject(err);
                });
            });
            await Promise.all([
                (0, util_1.autoUnregister)(stream, promise),
                (0, util_1.autoUnregister)(this.connection, promise)
            ]);
            unregisterDrainListener();
        };
        const readReply = async () => {
            const reply = await this.parser.readAscii(4);
            switch (reply) {
                case util_1.Reply.OKAY:
                    await this.parser.readBytes(4);
                    return;
                case util_1.Reply.FAIL:
                    throw await this.error();
                default:
                    throw this.parser.unexpected(reply, 'OKAY or FAIL');
            }
        };
        (async () => {
            try {
                await writeData();
                await readReply();
            }
            catch (err) {
                if (canceled) {
                    this.connection.end();
                    return;
                }
                transfer.emit('error', err);
            }
            finally {
                transfer.end();
            }
        })();
        transfer.once('cancel', () => (canceled = true));
        return transfer;
    }
    pushStream(stream, path, mode) {
        if (mode == null) {
            mode = SyncMode.DEFAULT_CHMOD;
        }
        mode |= stats_1.default.S_IFREG;
        this.sendCommandWithArg(util_1.Reply.SEND, `${path},${mode}`);
        return this.writeData(stream, Math.floor(Date.now() / 1000));
    }
    pushFile(file, path, mode) {
        if (mode === null) {
            mode = SyncMode.DEFAULT_CHMOD;
        }
        mode = mode || SyncMode.DEFAULT_CHMOD;
        return this.pushStream(fs_1.default.createReadStream(file), path, mode);
    }
    push(contents, path, mode) {
        if (typeof contents === 'string') {
            return this.pushFile(contents, path, mode);
        }
        return this.pushStream(contents, path, mode);
    }
    readData() {
        let canceled = false;
        const transfer = new pulltransfer_1.PullTransfer();
        const readNext = async () => {
            const reply = await this.parser.readAscii(4);
            switch (reply) {
                case util_1.Reply.DATA: {
                    const length = (await this.parser.readBytes(4)).readUInt32LE(0);
                    await this.parser.readByteFlow(length, transfer);
                    return readNext();
                }
                case util_1.Reply.DONE:
                    await this.parser.readBytes(4);
                    return;
                case util_1.Reply.FAIL:
                    return this.error();
                default:
                    throw this.parser.unexpected(reply, 'DATA, DONE or FAIL');
            }
        };
        (async () => {
            try {
                await readNext();
            }
            catch (err) {
                if (canceled) {
                    this.connection.end();
                    return;
                }
                transfer.emit('error', err);
            }
            finally {
                transfer.end();
            }
        })();
        transfer.once('cancel', () => (canceled = true));
        return transfer;
    }
    pull(path) {
        this.sendCommandWithArg(util_1.Reply.RECV, path);
        return this.readData();
    }
    async readDir(path) {
        const files = [];
        const readNext = async () => {
            const reply = await this.parser.readAscii(4);
            switch (reply) {
                case util_1.Reply.DENT: {
                    const stat = await this.parser.readBytes(16);
                    const [mode, size, mtime, nameLen] = [
                        stat.readUInt32LE(0),
                        stat.readUInt32LE(4),
                        stat.readUInt32LE(8),
                        stat.readUInt32LE(12)
                    ];
                    const name = (await this.parser.readBytes(nameLen)).toString();
                    if (!(name === '.' || name === '..')) {
                        files.push(new entry_1.default(name, mode, size, mtime));
                    }
                    return readNext();
                }
                case util_1.Reply.DONE:
                    await this.parser.readBytes(16);
                    return files;
                case util_1.Reply.FAIL:
                    throw await this.parser.readError();
                default:
                    throw this.parser.unexpected(reply, 'DENT, DONE or FAIL');
            }
        };
        this.sendCommandWithArg(util_1.Reply.LIST, path);
        return readNext();
    }
    end() {
        this.connection.end();
    }
    sendCommandWithArg(cmd, arg) {
        const arglen = Buffer.byteLength(arg, 'utf-8');
        const payload = Buffer.alloc(cmd.length + 4 + arglen);
        let pos = 0;
        payload.write(cmd, pos, cmd.length);
        pos += cmd.length;
        payload.writeUInt32LE(arglen, pos);
        pos += 4;
        payload.write(arg, pos);
        return this.connection.write(payload);
    }
}
exports.Sync = Sync;
