"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Tracker = void 0;
const events_1 = require("events");
const util_1 = require("./util");
const device_1 = require("./device");
class Tracker extends events_1.EventEmitter {
    /** @ignore */
    constructor(command, client) {
        super();
        this.ended = false;
        // assigning to null prevents emitting 'add' events on first read
        this.deviceMap = null;
        this.command = command;
        this.client = client;
        this.hook();
    }
    get Devices() {
        return Array.from(this.deviceMap?.values() || []);
    }
    async hook() {
        // Listener for error not needed, error is handled in catch for read()
        // this.command.connection.on('error', (err) => this.emit('error', err));
        this.command.connection.once('end', () => this.emit('end'));
        const endConnection = async () => {
            try {
                await this.command.parser.end();
                this.command.endConnection();
            }
            catch (err) {
                this.emit('error', err);
            }
        };
        try {
            await this.read();
        }
        catch (err) {
            if (!this.ended) {
                this.emit('error', err instanceof util_1.PrematureEOFError
                    ? new Error('Connection closed')
                    : err);
            }
        }
        finally {
            endConnection();
        }
    }
    async read() {
        const list = await this.command.readDevices();
        this.update(list);
        return this.read();
    }
    update(list) {
        const newMap = list.reduce((map, d) => {
            const currentDevice = this.deviceMap?.get(d.id) || new device_1.Device(this.client, d);
            map.set(d.id, currentDevice);
            if (d.state !== currentDevice.state) {
                currentDevice.state = d.state;
                this.emit('change', currentDevice);
                return map;
            }
            if (this.deviceMap && !this.deviceMap.has(d.id)) {
                this.emit('add', currentDevice);
                return map;
            }
            return map;
        }, new Map());
        this.deviceMap?.forEach((d) => {
            if (!newMap.has(d.id)) {
                const deviceObject = { ...d };
                delete deviceObject.client;
                this.emit('remove', deviceObject);
            }
        });
        this.deviceMap = newMap;
    }
    end() {
        this.ended = true;
        this.command.endConnection();
    }
    on(event, listener) {
        return super.on(event, listener);
    }
}
exports.Tracker = Tracker;
