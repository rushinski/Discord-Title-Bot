"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Monkey = void 0;
const util_1 = require("../util");
const reply_1 = require("./reply");
const api_1 = __importDefault(require("./api"));
const command_1 = require("./command");
const commandqueue_1 = require("./commandqueue");
const parser_1 = require("./parser");
class Monkey extends api_1.default {
    constructor() {
        super(...arguments);
        this.queue = [];
        this.parser = new parser_1.Parser();
        this.stream_ = null;
        this.timeout = undefined;
    }
    get stream() {
        if (!this.stream_) {
            throw new util_1.NotConnectedError();
        }
        return this.stream_;
    }
    sendInternal(commands, cmdConstruct) {
        [commands].flat().forEach((command) => {
            this.queue.push(cmdConstruct(command));
            this.stream.write(command + '\n');
        });
        this.timeout = setTimeout(() => {
            this.consume(new reply_1.ErrReply('Command failed'));
        }, 500);
        return this;
    }
    sendAndParse(commands, cb, parser) {
        return this.sendInternal(commands, (cmd) => new command_1.ParsableCommand(cmd, cb, parser));
    }
    /**
     * Writes commands to monkey stream.
     * @example
     * monkey.send('key event 24', (err, value, command) => {});
     */
    send(commands, cb) {
        return this.sendInternal(commands, (cmd) => new command_1.Command(cmd, cb));
    }
    hook() {
        this.stream.on('data', (data) => {
            clearTimeout(this.timeout);
            return this.parser.parse(data);
        });
        this.stream.on('error', (err) => {
            clearTimeout(this.timeout);
            return this.emit('error', err);
        });
        this.stream.on('end', () => {
            clearTimeout(this.timeout);
            return this.emit('end');
        });
        this.stream.on('finish', () => {
            clearTimeout(this.timeout);
            return this.emit('finish');
        });
        this.parser.on('reply', (reply) => {
            return this.consume(reply);
        });
        this.parser.on('error', (err) => {
            return this.emit('error', err);
        });
    }
    on(event, listener) {
        return super.on(event, listener);
    }
    consume(reply) {
        const command = this.queue.shift();
        if (!command) {
            this.emit('error', new Error('Command queue depleted, but replies still coming in'));
            return;
        }
        if (reply.isError()) {
            return command.callback?.(reply.toError(), null, command.command);
        }
        if (command.isParsable()) {
            return command.callback?.(null, command.parser(reply.value), command.command);
        }
        command.callback?.(null, reply.value, command.command);
    }
    connect(param) {
        this.stream_ = param;
        this.hook();
        return this;
    }
    end(cb) {
        clearTimeout(this.timeout);
        this.stream.end(cb);
        return this;
    }
    /**
     * Allows executing commands in a queue.
     * @example
     * monkey
     *      .commandQueue()
     *      .touchDown(100, 0)
     *      .sleep(5)
     *      .touchUp(100, 0)
     *      .execute((err, values) => {
     *          monkey.end();
     *      });
     */
    commandQueue() {
        return new commandqueue_1.CommandQueue(this);
    }
}
exports.Monkey = Monkey;
