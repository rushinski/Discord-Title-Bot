"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.LogcatReader = void 0;
const util_1 = require("../util");
const streamHandler_1 = __importDefault(require("../streamHandler"));
const binary_1 = require("./parser/binary");
class LogcatReader extends streamHandler_1.default {
    constructor(options) {
        super();
        this.parser = new binary_1.Binary();
        this.stream_ = null;
        this.filter = options?.filter;
    }
    get stream() {
        if (!this.stream_) {
            throw new util_1.NotConnectedError();
        }
        return this.stream_;
    }
    hook() {
        this.stream.on('data', (data) => {
            if (Buffer.isBuffer(data)) {
                return this.parser.parse(data);
            }
            this.emit('error', new Error('Invalid data'));
        });
        this.stream.on('error', (err) => {
            this.emit('error', err);
        });
        this.stream.on('end', () => {
            this.emit('end');
        });
        this.stream.on('finish', () => {
            this.emit('finish');
        });
        this.parser.on('entry', (entry) => {
            if (!this.filter || this.filter(entry)) {
                this.emit('entry', entry);
            }
        });
        this.parser.on('error', (err) => {
            this.emit('error', err);
        });
    }
    on(event, listener) {
        return super.on(event, listener);
    }
    connect(stream) {
        this.stream_ = stream;
        this.hook();
        return this;
    }
    end() {
        this.stream.end();
    }
}
exports.LogcatReader = LogcatReader;
